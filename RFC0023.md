# RFC0023
Amends and extends:  
* [RFC0010: Extension of Tool Interaction Support](https://github.com/pmix/RFCs/blob/master/RFC0010.md)
* [RFC0001: Provide a mechanism by which tools can interact with a local PMIx server that has opted to accept such connections](https://github.com/pmix/RFCs/blob/master/RFC0001.md)

## Title
Support for Launching Applications Under Debugger Tools

## Abstract
Prior RFCs have provided support for several typical use-cases involving tools interacting with applications and the general system management stack. One key use-case, however, has not been covered: the case where an application is actually launched under control of a tool. This RFC defines support for that mode of operation, and adds support for IO forwarding for all tools.

## Labels
[EXTENSION][CLIENT-API][SERVER-API][RM-INTERFACE][ATTRIBUTES]

## Action

## Copyright Notice
Copyright (c) 2017 Intel, Inc. All rights reserved.

This document is subject to all provisions relating to code contributions to the PMIx community as defined in the community's [LICENSE](https://github.com/pmix/RFCs/tree/master/LICENSE) file. Code Components extracted from this document must include the License text as described in that file.

## Description
Prior RFCs defined mechanisms and standards for connecting debuggers/tools to running jobs, and allowing a tool to itself launch a job, possibly in conjunction with its own daemons. Thus, they dealt with the following two use-cases:

#### Use-case I: attach to an executing application
In this case, the application is started by some other tool - e.g., either an "mpiexec" provided by the programming library, or a native launcher (such as "srun", "aprun", or "qsub") provided by the RM. This allows the user full access to the range of cmd line options of the launcher. The debugger is initiated at some random later time, typically when the application is detected as having encountered some problem. An example might look like:
```shell
$ mpiexec -n 3 ./myapp &
$ dbgr <pid-of-mpirun>
```
In this mode of operation, the debugger needs to discover the rendezvous information of the respective launcher and then connect to that PMIx server. 

#### Use-case 2: direct-launch an application using a debugger tool
In this case, the dbgr itself can use the PMIx spawn options to control the app’s startup, including directing the RM/app as to when to block and wait for debugger attachment, or stipulating that an interceptor library be preloaded. However, this means that the user is restricted to whatever cmd line options the debugger vendor has provided for operations such as process placement and binding, which places a significant burden on the debugger vendor. An example might look like the following:
```shell
$ dbgr -n 3 ./myapp
```
#### New use-case: indirect-launch using a debugger tool
A third use-case that is frequently used involves executing a program under a debugger using a launcher such as mpirun. In other words, the user would execute the application/debugging session using something like the following command line:
```shell
$ dbgr mpiexec -n 3 ./myapp
```
This is an important case for users needing to debug their application from the start of execution. It is a little tricky, however, as it requires some degree of coordination between the dbgr tool and the launcher. Ultimately, it is the launcher that is going to launch the app, and the dbgr must somehow inform it (and the app) that this is being done in a debug session so that the app knows to “block” until the debugger attaches to it. There are also potential modifications to the launch directive required by the debugger (e.g., to preload an interceptor library).

Prior approaches relied on the debugger to modify the launcher's cmd line, exploiting that launcher's cmd line options to create the desired behavior. This has been problematic for debugger vendors as every launcher is different, thus requiring the debugger tool to be customized for each implementation. This RFC is focused on eliminating that burden by defining a PMIx-based standard mechanism for the coordination.

Support for this use-case will occur in several distinct phases.

#### Phase I: Launcher startup
Given that the launcher appears on the debugger tool's cmd line, we assume for the purpose of this use-case that the debugger tool is responsible for launching the launcher itself. If the user is operating in an environment under the control of a PMIx-enabled workload manager (WLM), then the debugger tool can utilize the PMIx_Spawn interface to start the launcher. Otherwise, it can utilize something like the standard "fork/exec" method to execute the launcher.

The critical element here is that the debugger tool include appropriate environmental variables 

#### Phase II: Initial tool-launcher connection


#### Phase III. IO Forwarding
In addition to adding support for the indirect-launch use-case, this RFC extends support for all tools by adding the ability for the RM to forward output from applications to a tool, and to forward stdin from the tool to one or more application processes. Enabling this requires the addition of several new attributes and APIs. 

* PMIX\_IOF\_FWD\_STDIN: forward the stdin from this tool to the specified processes

* PMIX\_IOF\_FWD\_STDOUT: forward stdout from the specified processes to this tool

* PMIX\_IOF\_FWD\_STDERR: forward stderr from the specified processes to this tool

* PMIX\_IOF\_FWD\_STDDIAG: if a diagnostic channel exists, forward any output on it from the specified processes to this tool

Tools can register for IO forwarding service by calling:
```
PMIX_EXPORT pmix_status_t PMIx_IOF_register(const pmix_proc_t procs[], size_t nprocs,
                                            const pmix_info_t directives[], size_t ndirs,
                                            pmix_iof_cbfunc_t cbfunc, void *cbdata);
```

Requests for IO forwarding are relayed to the host RM via a corresponding callback function:
```
typedef pmix_status_t (*pmix_server_iof_fn_t)(const pmix_proc_t procs[], size_t nprocs,
                                              const pmix_info_t directives[], size_t ndirs,
                                              pmix_op_cbfunc_t cbfunc, void *cbdata);
```

The registration callback provides a registration number that can subsequently be used to deregister, and to transmit IO to/from the tool. Deregistration is done via the following API:
```
PMIX_EXPORT pmix_status_t PMIx_IOF_deregister(size_t registration_id,
                                              const pmix_info_t directives[], size_t ndirs,
                                              pmix_op_cbfunc_t cbfunc, void *cbdata);
```

The host RM passes any collected IOF to the PMIx server for transmission to one or more clients (as per the registration) via the following API:
```
PMIX_EXPORT pmix_status_t PMIx_IOF_push(size_t registration_id, const pmix_byte_object_t *bo,
                                        const pmix_info_t directives[], size_t ndirs,
                                        pmix_op_cbfunc_t cbfunc, void *cbdata);
```
Similarly, the PMIx server passes stdin to the host RM for transmission to the recipients (as per the registration) via the following callback function:
```
typedef pmix_status_t (*pmix_server_stdin_fn_t)(size_t registration_id, const pmix_byte_object_t *bo,
                                                const pmix_info_t directives[], size_t ndirs,
                                                pmix_op_cbfunc_t cbfunc, void *cbdata);
```

The desired behavior might be something like the following:

* the debugger starts mpirun with some method for telling it that it is being started as part of a debugging session. Options might include setting some PMIX_foo environmental variable, perhaps with rendezvous information for the debugger tool

* once mpirun itself starts up, it would connect back to the debugger tool via PMIx. This will take a little thought as (in most cases) mpirun would probably set itself up as a PMIx server to support its local application clients. Still, we do have prior examples upon which to base this operation - e.g., singletons connecting to a spawned support daemon.

* the debugger tool and mpirun would exchange information on how the debugger wants the job to be spawned. For example:
   * the debugger might check to see if mpirun can stop-on-first-instruction, or only supports stop-in-init, and then direct mpirun as to which option should be used. 
   * request that mpirun co-launch the debugger daemons

* mpirun would launch the application, and then alert the debugger tool when the procs are ready. At this time, the debugger tool could query the process map and other information about the job

Some of these mechanisms fit within our existing capabilities, but some will require additional attributes and/or possible APIs. Regardless, we will need to clearly delineate this procedure so that debuggers/tools and RMs/RTEs will know their required roles/responsibilities in executing it.

## Protoype Implementation
Provide a reference link to the accompanying Pull Request (PR) against the PMIx master repository. If the prototype implementation has been tested against an appropriately modified resource manager and/or client program, then references to those prototypes should be provided. Note that approval of any RFC will be far more likely to happen if such validation has been performed!

## Author(s)
Ralph H. Castain  
Intel, Inc.  
Github: rhc54  
